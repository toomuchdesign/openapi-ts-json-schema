import fs from 'fs/promises';
import { existsSync } from 'fs';
import path from 'node:path';
import $RefParser from '@apidevtools/json-schema-ref-parser';
import YAML from 'yaml';
import get from 'lodash.get';
import {
  clearFolder,
  makeJsonSchemaFiles,
  REF_SYMBOL,
  convertOpenApiToJsonSchema,
  convertOpenApiParameters,
  addSchemaToMetaData,
  pathToRef,
  formatTypeScript,
  saveFile,
  makeRelativePath,
} from './utils';
import type {
  SchemaPatcher,
  SchemaMetaDataMap,
  JSONSchema,
  ReturnPayload,
  Plugin,
} from './types';

export async function openapiToTsJsonSchema({
  openApiSchema: openApiSchemaRelative,
  definitionPathsToGenerateFrom,
  schemaPatcher,
  outputPath: providedOutputPath,
  plugins = [],
  silent,
  refHandling = 'inline',
}: {
  openApiSchema: string;
  definitionPathsToGenerateFrom: string[];
  schemaPatcher?: SchemaPatcher;
  outputPath?: string;
  plugins?: ReturnType<Plugin>[];
  silent?: boolean;
  refHandling?: 'inline' | 'import' | 'keep';
}): Promise<ReturnPayload> {
  if (definitionPathsToGenerateFrom.length === 0 && !silent) {
    console.log(
      `[openapi-ts-json-schema] ⚠️ No schemas will be generated since definitionPathsToGenerateFrom option is empty`,
    );
  }

  definitionPathsToGenerateFrom.forEach((defPath) => {
    if (path.isAbsolute(defPath)) {
      throw new Error(
        `[openapi-ts-json-schema] "definitionPathsToGenerateFrom" must be an array of relative paths. "${defPath}" found.`,
      );
    }
  });

  const openApiSchemaPath = path.resolve(openApiSchemaRelative);
  if (!existsSync(openApiSchemaPath)) {
    throw new Error(
      `[openapi-ts-json-schema] Provided OpenAPI definition path doesn't exist: ${openApiSchemaPath}`,
    );
  }

  const outputPath =
    providedOutputPath ??
    path.resolve(path.dirname(openApiSchemaPath), 'schemas-autogenerated');

  await clearFolder(outputPath);

  const openApiSchema = await fs.readFile(openApiSchemaPath, 'utf-8');
  const jsonOpenApiSchema: Record<string, any> = YAML.parse(openApiSchema);
  // Resolve/inline remote and URL $ref's (keeping local ones "#/...")
  const bundledOpenApiSchema = await $RefParser.bundle(jsonOpenApiSchema);
  const initialJsonSchema = convertOpenApiToJsonSchema(bundledOpenApiSchema);

  const inlinedRefs: Map<string, JSONSchema> = new Map();
  const dereferencedJsonSchema = await $RefParser.dereference(
    initialJsonSchema,
    {
      dereference: {
        // @ts-expect-error onDereference seems not to be properly typed
        onDereference: (ref, inlinedSchema) => {
          /**
           * "import" refHandling support:
           * mark inlined ref objects with a "REF_SYMBOL" prop to replace them later on
           */
          inlinedSchema[REF_SYMBOL] = ref;

          /**
           * "inline" refHandling support:
           * add a $ref comment to each inlined schema with the original ref value.
           * See: https://github.com/kaelzhang/node-comment-json
           */
          inlinedSchema[Symbol.for('before')] = [
            {
              type: 'LineComment',
              value: ` $ref: "${ref}"`,
            },
          ];

          // Keep track of inlined refs
          inlinedRefs.set(ref, inlinedSchema);
        },
      },
    },
  );

  const jsonSchema = convertOpenApiParameters(dereferencedJsonSchema);
  const schemaMetaDataMap: SchemaMetaDataMap = new Map();

  /**
   * Generate meta data for schemas which have been previously dereferenced.
   * It happens for "import" and "keep" refHandling since they expect to find
   * $ref schemas generated as standalone schemas
   */
  if (refHandling === 'import' || refHandling === 'keep') {
    for (const [ref, schema] of inlinedRefs) {
      addSchemaToMetaData({
        id: ref,
        schemaMetaDataMap,
        schema,
        outputPath,
        schemaPatcher,
        refHandling,
        isRef: true,
      });
    }
  }

  // Generate schema meta info for user requested schemas
  for (const definitionPath of definitionPathsToGenerateFrom) {
    const definitionSchemas = get(jsonSchema, definitionPath);
    for (const schemaName in definitionSchemas) {
      // Create expected OpenAPI ref
      const id = pathToRef({
        schemaRelativeDirName: definitionPath,
        schemaName,
      });

      addSchemaToMetaData({
        id,
        schemaMetaDataMap,
        schema: definitionSchemas[schemaName],
        outputPath,
        schemaPatcher,
        refHandling,
        isRef: inlinedRefs.has(id),
      });
    }
  }

  await makeJsonSchemaFiles({
    refHandling,
    schemaMetaDataMap,
  });

  const returnPayload: ReturnPayload = {
    outputPath,
    metaData: { schemas: schemaMetaDataMap },
  };

  // Execute plugins
  for (const plugin of plugins) {
    await plugin({
      ...returnPayload,
      utils: { makeRelativePath, formatTypeScript, saveFile },
    });
  }

  if (!silent) {
    console.log(
      `[openapi-ts-json-schema] ✅ JSON schema models generated at ${outputPath}`,
    );
  }

  return returnPayload;
}
