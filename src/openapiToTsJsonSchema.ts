import fs from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';
import $RefParser from '@apidevtools/json-schema-ref-parser';
import YAML from 'yaml';
import get from 'lodash.get';
import {
  clearFolder,
  makeJsonSchemaFile,
  REF_SYMBOL,
  SchemaPatcher,
  convertOpenApiToJsonSchema,
  convertOpenApiParameters,
  refToPath,
  replaceInlinedRefsWithStringPlaceholder,
  InlinedRefs,
  SchemaMetaInfoMap,
} from './utils';

export async function openapiToTsJsonSchema({
  openApiSchema: openApiSchemaRelative,
  definitionPathsToGenerateFrom,
  schemaPatcher,
  outputPath: providedOutputPath,
  silent,
  experimentalImportRefs = false,
}: {
  openApiSchema: string;
  definitionPathsToGenerateFrom: string[]; // @TODO validate to be relative paths
  schemaPatcher?: SchemaPatcher;
  outputPath?: string;
  silent?: boolean;
  experimentalImportRefs?: boolean;
}) {
  if (definitionPathsToGenerateFrom.length === 0 && !silent) {
    console.log(
      `[openapi-ts-json-schema] ⚠️ No schemas will be generated since definitionPathsToGenerateFrom option is empty`,
    );
  }

  const openApiSchemaPath = path.resolve(openApiSchemaRelative);
  if (!existsSync(openApiSchemaPath)) {
    throw new Error(
      `Provided OpenAPI definition path doesn't exist: ${openApiSchemaPath}`,
    );
  }

  const outputPath =
    providedOutputPath ??
    path.resolve(path.dirname(openApiSchemaPath), 'schemas-autogenerated');

  await clearFolder(outputPath);

  const openApiSchema = await fs.readFile(openApiSchemaPath, 'utf-8');
  const jsonOpenApiSchema: Record<string, any> = YAML.parse(openApiSchema);
  // Resolve external/remote references (keeping $refs)
  const bundledOpenApiSchema = await $RefParser.bundle(jsonOpenApiSchema);
  const initialJsonSchema = convertOpenApiToJsonSchema(bundledOpenApiSchema);

  const inlinedRefs: InlinedRefs = new Map();
  const dereferencedJsonSchema = await $RefParser.dereference(
    initialJsonSchema,
    {
      dereference: {
        // @ts-expect-error onDereference seems not to be properly typed
        onDereference: (ref, inlinedSchema) => {
          if (experimentalImportRefs) {
            // Mark inlined refs with a "REF_SYMBOL" prop
            inlinedSchema[REF_SYMBOL] = ref;

            // Keep track of inline refs
            inlinedRefs.set(ref, inlinedSchema);
          } else {
            /**
             * Add a $ref comment to each inlined schema with the original ref value. Using:
             * https://github.com/kaelzhang/node-comment-json
             */
            inlinedSchema[Symbol.for('before')] = [
              {
                type: 'LineComment',
                value: ` $ref: "${ref}"`,
              },
            ];
          }
        },
      },
    },
  );

  let jsonSchema = convertOpenApiParameters(dereferencedJsonSchema);
  const schemasToGenerate: SchemaMetaInfoMap = new Map();

  if (experimentalImportRefs) {
    // Generate schema meta info for inlined refs, first
    for (const [ref, schema] of inlinedRefs) {
      const { schemaRelativePath, schemaRelativeDirName, schemaName } =
        refToPath(ref);
      schemasToGenerate.set(schemaRelativePath, {
        schemaAbsoluteDirName: path.join(outputPath, schemaRelativeDirName),
        schemaName,
        schema: replaceInlinedRefsWithStringPlaceholder(schema),
      });
    }
  }

  // Generate schema meta info for user requested schemas
  for (const definitionPath of definitionPathsToGenerateFrom) {
    const schemas = get(jsonSchema, definitionPath);

    for (const schemaName in schemas) {
      const schemaRelativePath = path.join(definitionPath, schemaName);
      // Do not override existing meta info of inlined schemas
      if (schemasToGenerate.has(schemaRelativePath) === false) {
        schemasToGenerate.set(schemaRelativePath, {
          schemaAbsoluteDirName: path.join(outputPath, definitionPath),
          schemaName,
          schema: experimentalImportRefs
            ? replaceInlinedRefsWithStringPlaceholder(schemas[schemaName])
            : schemas[schemaName],
        });
      }
    }
  }

  for (const [_, schemaMetaInfo] of schemasToGenerate) {
    await makeJsonSchemaFile({
      schemaMetaInfo,
      schemasToGenerate,
      schemaPatcher,
      inlinedRefs,
    });
  }

  if (!silent) {
    console.log(
      `[openapi-ts-json-schema] ✅ JSON schema models generated at ${outputPath}`,
    );
  }
  return { outputPath };
}
